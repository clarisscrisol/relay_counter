module fifobuffer # (parameter abits = 3, dbits = 8)
(
      input clock,
      input reset,
      input wr,                             //rx_done_tick
      input rd,                             //rd_done from data interpreter
      input [dbits-1:0] din,
      output [dbits-1:0] dout   );
 
reg [dbits-1:0] out;
reg [dbits-1:0] regarray[2**abits-1:0];
reg [abits-1:0] wr_reg, wr_next, wr_succ;   //points to the register that needs to be written to (head)
reg [abits-1:0] rd_reg, rd_next, rd_succ;   //points to the register that needs to be read from (tails)

//always block for write operation
always @(posedge wr)
  begin
      regarray[wr_reg] <= din;  //at wr_reg location of regarray store what is given at din
    end
  
//always block for read operation
always @(posedge rd)
  begin
      out <= regarray[rd_reg];
    end
  
 
always @(posedge clock or posedge reset)
  begin
    if (reset)
      begin
      wr_reg <= 0;
      rd_reg <= 0;
      end
   
    else
      begin
        wr_reg <= wr_next;
        rd_reg <= rd_next;
      end
  end
  
always @(*)

  begin
    wr_succ = wr_reg + 1;     //assigned to new value as wr_next cannot be tested for in same always block
    rd_succ = rd_reg + 1;     //assigned to new value as rd_next cannot be tested for in same always block
    wr_next = wr_reg;         //defaults state stays the same
    rd_next = rd_reg;         //defaults state stays the same   
 
 case({wr,rd})
    
  //2'b00: do nothing LOL..
     
    2'b01: //read
      begin
            rd_next = rd_succ;
      end
     
    2'b10: //write
      begin
           wr_next = wr_succ;
      end
      
    2'b11: //read and write
      begin
        wr_next = wr_succ;
        rd_next = rd_succ;
      end
  endcase
    
 end

assign dout = out;

endmodule
